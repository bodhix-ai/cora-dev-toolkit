# =============================================================================
# CORA Project Setup Configuration
# =============================================================================
#
# This file contains all environment-specific configuration for setting up
# a new CORA project. Copy this file to setup.config.{project}.yaml and fill
# in your values (e.g., setup.config.ai-sec.yaml, setup.config.pm-app.yaml).
#
# IMPORTANT: Never commit setup.config.*.yaml to version control!
#            These files contain sensitive credentials.
# =============================================================================

# Project Identification
project:
  name: "{{PROJECT_NAME}}" # Project name (lowercase, alphanumeric, hyphens)
  display_name: "My CORA App" # Human-readable project name
  description: "CORA-compliant application"
  organization: "{{ORGANIZATION_NAME}}" # GitHub organization

# GitHub Repository Configuration
github:
  owner: "{{ORGANIZATION_NAME}}" # GitHub organization or username
  repo_stack: "{{PROJECT_NAME}}-stack" # Stack repository name
  repo_infra: "{{PROJECT_NAME}}-infra" # Infrastructure repository name

# Environment Configuration
# This file should be for ONE environment (dev, stg, or prd)
environment: dev # dev | stg | prd

# =============================================================================
# Supabase Configuration
# =============================================================================
# Get these from: https://supabase.com/dashboard/project/<project>/settings/api
supabase:
  # Project URL (e.g., https://abcdefghijk.supabase.co)
  url: ""

  # Anon/Public Key - Safe to expose in frontend
  anon_key: ""

  # Service Role Key - KEEP SECRET! Only for backend/Lambda use and schema deployment
  service_role_key: ""

  # JWT Secret - KEEP SECRET! Used for JWT token generation
  # Get from: Supabase Dashboard → Settings → API → JWT Secret
  jwt_secret: ""

  # Direct PostgreSQL Database Connection
  # Required for: schema deployment, schema validation
  # Get from: Supabase Dashboard → Settings → Database → Connection string
  #
  # IMPORTANT: Use the DIRECT connection format, not the pooler:
  #   - Host: db.{project-ref}.supabase.co (NOT aws-0-*.pooler.supabase.com)
  #   - Port: 5432 (NOT 6543)
  #   - User: postgres (NOT postgres.{project-ref})
  db:
    host: "" # e.g., db.abcdefghijk.supabase.co (DIRECT connection, not pooler)
    port: 5432 # Direct connection port (not 6543 pooler port)
    name: "postgres" # Usually "postgres"
    user: "postgres" # Use 'postgres' for direct connection
    password: "" # From Supabase Dashboard → Settings → Database

# =============================================================================
# AWS Configuration
# =============================================================================
aws:
  region: "us-east-1"
  profile: "" # AWS CLI profile name (optional)

  # Terraform State Backend (created by bootstrap script)
  terraform:
    state_bucket: "" # e.g., {project}-terraform-state
    dynamodb_table: "" # e.g., {project}-terraform-lock

  # API Gateway (populated after infra deployment)
  api_gateway:
    id: ""
    endpoint: "" # e.g., https://abc123.execute-api.us-east-1.amazonaws.com

# =============================================================================
# Authentication Provider
# =============================================================================
# Choose ONE authentication provider: either Okta OR Clerk
# Comment out the one you're not using

auth_provider: "okta" # "okta" or "clerk"

# --- Okta Configuration ---
# Get these from your Okta Developer Console: https://developer.okta.com
okta:
  domain: "" # e.g., dev-12345678.okta.com
  client_id: ""
  client_secret: "" # KEEP SECRET!
  issuer: "" # e.g., https://dev-12345678.okta.com/oauth2/default
  jwks_uri: "" # e.g., https://dev-12345678.okta.com/oauth2/default/v1/keys
  audience: api://default

# --- Clerk Configuration ---
# Get these from your Clerk Dashboard: https://dashboard.clerk.com
clerk:
  publishable_key: "" # e.g., pk_test_xxx or pk_live_xxx
  secret_key: "" # KEEP SECRET! e.g., sk_test_xxx or sk_live_xxx
  jwt_key: "" # KEEP SECRET! (for API route verification)
  # Optional: Clerk Frontend API URL (usually auto-detected)
  # frontend_api: ""

# =============================================================================
# NextAuth.js Configuration
# =============================================================================
# NextAuth.js is the authentication library used in CORA Next.js applications.
# It handles:
#   - Session management (JWT or database sessions)
#   - OAuth provider integration (Okta, Clerk, etc.)
#   - CSRF protection
#   - Secure cookie handling
#
# These values are required regardless of which auth provider you choose.
nextauth:
  # NEXTAUTH_SECRET - Used to encrypt JWTs and session cookies
  # Generate with: openssl rand -base64 32
  secret: ""

  # NEXTAUTH_URL - The canonical URL of your site
  # For dev: http://localhost:3000
  # For prod: https://your-domain.com
  url: ""

# =============================================================================
# AI Provider Configuration
# =============================================================================
# Configure authentication for AI providers used in the platform.
# Supports multiple authentication methods based on provider type.
#
# Authentication Methods:
#   - iam_role: Use AWS IAM role (recommended for AWS Bedrock)
#   - secrets_manager: Store credentials in AWS Secrets Manager
#   - ssm_parameter: Store credentials in AWS Systems Manager Parameter Store
#
# Security Best Practices:
#   - Prefer IAM role-based auth when possible (no long-term credentials)
#   - Use Secrets Manager for non-AWS providers (Azure, Google)
#   - Never use environment variables for production credentials
#
# For detailed setup instructions, see:
#   docs/guides/ai-provider-authentication.md

ai_providers:
  # AWS Bedrock (Recommended: IAM Role-Based Auth)
  # -------------------------------------------------
  # AWS Bedrock is the recommended provider for production deployments.
  # It supports IAM role-based authentication, eliminating the need for
  # long-term credentials.
  aws_bedrock:
    enabled: true
    auth_method: "iam_role"  # "iam_role" | "secrets_manager" | "ssm_parameter"
    
    # For IAM role auth (recommended):
    # Leave credentials_secret_path empty. Ensure Lambda execution role has
    # bedrock:InvokeModel permission (automatically added by Terraform).
    credentials_secret_path: ""
    
    # For Secrets Manager auth (alternative):
    # credentials_secret_path: "arn:aws:secretsmanager:us-east-1:123456789012:secret:my-project/ai/bedrock"
    
    # For SSM Parameter Store auth (dev only):
    # credentials_secret_path: "/my-project/ai/bedrock/api-key"
    
  # Azure OpenAI (Requires API Key via Secrets Manager)
  # -------------------------------------------------
  # Azure OpenAI requires an API key stored in AWS Secrets Manager.
  # 
  # Setup Steps:
  # 1. Create Azure OpenAI resource: https://portal.azure.com
  # 2. Copy API key from Keys and Endpoint section
  # 3. Create AWS secret: aws secretsmanager create-secret --name my-project/ai/azure_openai --secret-string "YOUR_AZURE_API_KEY"
  # 4. Update credentials_secret_path below with the secret ARN
  azure_ai_foundry:
    enabled: false
    auth_method: "secrets_manager"  # Azure requires API key
    credentials_secret_path: ""  # e.g., "arn:aws:secretsmanager:us-east-1:123456789012:secret:my-project/ai/azure_openai"
    
    # Azure-specific configuration
    azure:
      endpoint: ""  # e.g., "https://your-resource.openai.azure.com/"
      api_version: "2024-02-15-preview"
      
  # Google Vertex AI (Requires Service Account via Secrets Manager)
  # -------------------------------------------------
  # Google Vertex AI requires a service account JSON key stored in AWS Secrets Manager.
  #
  # Setup Steps:
  # 1. Create service account: https://console.cloud.google.com/iam-admin/serviceaccounts
  # 2. Grant Vertex AI User role
  # 3. Create and download JSON key
  # 4. Create AWS secret: aws secretsmanager create-secret --name my-project/ai/google_vertex --secret-string file://service-account-key.json
  # 5. Update credentials_secret_path below with the secret ARN
  google_ai:
    enabled: false
    auth_method: "secrets_manager"  # Google requires service account JSON
    credentials_secret_path: ""  # e.g., "arn:aws:secretsmanager:us-east-1:123456789012:secret:my-project/ai/google_vertex"
    
    # Google-specific configuration
    google:
      project_id: ""
      location: "us-central1"

# =============================================================================
# Module Configuration
# =============================================================================
# Configure which functional modules to include in your project.
# Core modules (module-access, module-ai, module-mgmt) are always included.
#
# Available Functional Modules:
#   - module-ws: Workspace Management (collaborative workspace containers)
#   - module-kb: Knowledge Base (RAG-based knowledge management) [Coming Soon]
#   - module-chat: Chat & Messaging (real-time communication) [Coming Soon]
#
# Module configurations are automatically merged from each module's
# module.config.yaml file when enabled.
modules:
  # List of functional modules to enable
  # Dependencies are automatically resolved (e.g., enabling module-kb also enables module-ai)
  enabled:
    - module-ws
    # - module-kb
    # - module-chat

# =============================================================================
# Validation Settings
# =============================================================================
validation:
  # Run schema validation after deployment
  run_schema_validation: true

  # Run API endpoint tests
  run_api_tests: true

  # Verify RLS policies
  verify_rls: true
