# CORA Development Toolkit - Cline Rules

## üõë STOP - READ THIS FIRST

**Before ANY action, run: `ls .cline/workflows/` and check if a workflow exists.**

| Task | MUST USE | NEVER DO |
|------|----------|----------|
| Syncing fixes | `/fix-and-sync.md <filename>` | ‚ùå Running `sync-fix-to-project.sh` directly |
| Testing modules | `/test-module.md <module>` | ‚ùå Running `create-cora-project.sh` directly |
| Fixing errors | `/fix-cycle.md` | ‚ùå Manual fixes without workflow |
| Validating | `/validate.md` | ‚ùå Running validators directly |

**Workflows handle placeholder substitution, path mapping, and next steps automatically.**

---

## ‚ö†Ô∏è CRITICAL: ALWAYS USE WORKFLOWS FIRST

**BEFORE doing ANYTHING, check if a workflow exists in `.cline/workflows/` for the task.**

| Task | Workflow to Use | NEVER |
|------|----------------|-------|
| Testing a new module | `.cline/workflows/test-module.md` | ‚ùå DO NOT run `create-cora-project.sh` directly |
| Fixing errors | `.cline/workflows/fix-cycle.md` or domain-specific `/fix-*.md` | ‚ùå DO NOT manually fix without workflow |
| Validating code | `.cline/workflows/validate.md` | ‚ùå DO NOT run validators directly |
| Syncing fixes | `.cline/workflows/fix-and-sync.md` | ‚ùå DO NOT manually copy files |

**If you bypass a workflow when one exists, you are doing it WRONG.**

**Example of correct behavior:**
- User says: "test module-voice"
- ‚úÖ CORRECT: Use `.cline/workflows/test-module.md` workflow
- ‚ùå WRONG: Run `create-cora-project.sh` directly

**Workflows save time, enforce standards, and prevent errors. Use them.**

---

## Project Overview

This is the **CORA Development Toolkit** repository - the authoritative source for CORA (Composable Organizational Resource Architecture) standards, templates, and tooling. This toolkit is used to create and develop CORA-compliant applications.

## Purpose

This toolkit enables:

1. **New CORA Project Creation** - Scaffolding for {project}-infra and {project}-stack repos
2. **Module Development** - Templates and validation for CORA modules
3. **Compliance Validation** - Automated checking of CORA standards
4. **Documentation** - Comprehensive guides for developers and AI agents

## Repository Structure

```
cora-dev-toolkit/
‚îú‚îÄ‚îÄ .clinerules                 # This file - AI agent instructions
‚îú‚îÄ‚îÄ .gitignore                  # Git ignore patterns
‚îú‚îÄ‚îÄ README.md                   # Toolkit overview
‚îú‚îÄ‚îÄ INTEGRATION-GUIDE.md        # How to use the toolkit
‚îú‚îÄ‚îÄ config/                     # Linting and dependency configs
‚îú‚îÄ‚îÄ docs/                       # CORA standards documentation
‚îú‚îÄ‚îÄ scripts/                    # Automation scripts
‚îú‚îÄ‚îÄ templates/                  # Project and module templates
‚îî‚îÄ‚îÄ memory-bank/                # AI context for toolkit development
```

## Key Documents

Before making changes, review these in order:

1. `memory-bank/README.md` - Current toolkit context
2. `docs/CORA-DEVELOPMENT-TOOLKIT-PLAN.md` - Master implementation plan
3. `docs/CORA-PROJECT-BOILERPLATE.md` - Project creation standards (when created)
4. `docs/CORA-CORE-MODULES.md` - Core module specifications (when created)

## Lambda Route Docstring Standard

CORA Lambda functions using **dynamic routing** (dispatcher pattern) MUST document their routes in the module docstring. See: `docs/standards/standard_LAMBDA-ROUTE-DOCSTRING.md`

**Required format in `lambda_function.py`:**
```python
"""
Module Name - Description

Routes - Category:
- GET /path - Description
- POST /path/{id} - Description
"""
```

This enables the API Tracer validator to match API Gateway routes to Lambda handlers during static analysis.

## Module Classification and Locations

**Authoritative Sources:**
- **Classification Criteria:** `docs/arch decisions/ADR-013-CORE-MODULE-CRITERIA.md`
- **Module Registry:** `templates/_modules-core/module-registry.yaml`

CORA uses a strict naming convention for modules: `module-{purpose}` where `{purpose}` is a **single word** describing the module's main responsibility.

### Module Locations (Source of Truth)

| Module | Type | Tier | Location |
|--------|------|------|----------|
| module-access | Core | 1 | `templates/_modules-core/module-access/` |
| module-ai | Core | 2 | `templates/_modules-core/module-ai/` |
| module-mgmt | Core | 3 | `templates/_modules-core/module-mgmt/` |
| module-kb | Core | 3 | `templates/_modules-core/module-kb/` |
| module-chat | Core | 3 | `templates/_modules-core/module-chat/` |
| module-ws | Functional | - | `templates/_modules-functional/module-ws/` |
| module-eval | Functional | - | `templates/_modules-functional/module-eval/` |
| module-voice | Functional | - | `templates/_modules-functional/module-voice/` |

### Core Modules (Required - Always Included)

Core modules are REQUIRED for all CORA projects and follow a tier system for boot order:

- **Tier 1:** `module-access` - Identity & access control (foundation)
- **Tier 2:** `module-ai` - AI provider management (platform services)
- **Tier 3:** `module-mgmt` - Platform management & monitoring
- **Tier 3:** `module-kb` - Knowledge base & RAG (core AI capability)
- **Tier 3:** `module-chat` - Chat & messaging (core AI capability)

**Why KB and Chat are Core:** CORA is an AI application framework. Knowledge retrieval (KB) and chat interaction (Chat) are fundamental capabilities for AI applications, not optional features. See ADR-013 for full rationale.

### Functional Modules (Optional - Per-Project Selection)

Functional modules are OPTIONAL and can be enabled based on project needs:

- `module-ws` - Workspace management (multi-tenancy)
- `module-eval` - Model evaluation & testing
- `module-voice` - Voice interaction capabilities
- (Future functional modules as needed)

## Module Build Script Locations

**CRITICAL:** CORA module Lambda build scripts are in the **STACK REPO**, NOT the infra repo.

### The Correct Location:

‚úÖ **CORRECT:** `{project}-stack/packages/module-{name}/backend/build.sh`
‚ùå **WRONG:** `{project}-infra/lambdas/module-{name}/{lambda}/build.sh`

### Why This Matters:

**Stack repo** = Lambda SOURCE CODE + BUILD SCRIPTS
**Infra repo** = Lambda DEPLOYMENT + Terraform configs

The `build-cora-modules.sh` script:
1. Finds modules in stack repo: `{project}-stack/packages/module-*/`
2. Runs their build scripts: `{module}/backend/build.sh`
3. Outputs to: `{module}/backend/.build/*.zip`
4. Copies zips to: `{project}-infra/build/{module-name}/`

**Example:**
```bash
# Module build script location (STACK REPO):
~/code/bodhix/testing/test-eval/ai-sec-stack/packages/module-eval/backend/build.sh

# NOT in infra repo:
~/code/bodhix/testing/test-eval/ai-sec-infra/lambdas/module-eval/eval-results/build.sh  ‚ùå
```

### When Deploying a Single Lambda:

The `deploy-lambda.sh` script must:
1. Find the module in the **stack repo**
2. Run `{stack-repo}/packages/{module}/backend/build.sh`
3. Find the built zip in `{module}/backend/.build/{lambda-name}.zip`
4. Upload to S3 and deploy via Terraform

**Impact:** If you look for build.sh in the infra repo, it won't exist and deployment fails. Always build from stack repo.

---

## Module Route File Locations

**CRITICAL:** CORA functional modules have routes at the **MODULE ROOT** level, NOT in `frontend/`.

### The Correct Location:

‚úÖ **CORRECT:** `templates/_modules-functional/{module-name}/routes/`
‚ùå **WRONG:** `templates/_modules-functional/{module-name}/frontend/routes/`

### Why This Matters:

The `scripts/create-cora-project.sh` script copies routes from `{module}/routes/`, **NOT** from `{module}/frontend/routes/`.

**Example:**
```bash
# create-cora-project.sh looks here:
routes_dir="${FUNCTIONAL_MODULE_TEMPLATE}/routes/"

# NOT here:
# routes_dir="${FUNCTIONAL_MODULE_TEMPLATE}/frontend/routes/"  ‚ùå
```

### When Modifying Module Routes:

1. **Always update routes in:** `templates/_modules-functional/{module}/routes/`
2. **Never update routes in:** `templates/_modules-functional/{module}/frontend/routes/`
3. The `routes/` directory at module root is the **source of truth** for project creation

### Common Error:

Placing routes in `frontend/routes/` means they won't be copied during project creation, causing the fix to not appear in newly created projects.

**Impact:** Route fixes placed in wrong directory won't propagate to new projects, wasting time and causing confusion.

## Two-Repo Pattern

Every CORA project uses two repositories:

- `{project}-infra` - Infrastructure as Code (Terraform, deploy scripts)
- `{project}-stack` - Application Code (Next.js app, CORA modules)

## Development Guidelines

### When Creating Templates

1. Use `{project}` placeholder for project-specific names
2. Use `{module}` placeholder for module-specific names
3. Never hardcode project prefixes like `pm-app-`
4. All infrastructure must be configurable via variables

### When Creating Documentation

1. Documentation lives in `docs/`
2. Use clear, actionable language
3. Include examples and anti-patterns
4. Reference the implementation plan phases

### When Creating Scripts

1. Scripts live in `scripts/`
2. Make scripts executable (`chmod +x`)
3. Include `--help` option
4. Support `--dry-run` for destructive operations

### When Creating Lambda Infrastructure

**CRITICAL:** All Lambda functions MUST use proper Terraform configuration for code change detection.

**Required Pattern:**
```hcl
resource "aws_lambda_function" "my_function" {
  filename         = var.lambda_zip
  source_code_hash = filebase64sha256(var.lambda_zip)  # ‚úÖ REQUIRED
  runtime          = "python3.11"  # MUST match org-common layer
  
  lifecycle {
    create_before_destroy = true  # ‚úÖ Blue-green deployment
  }
}
```

**NEVER use:**
```hcl
lifecycle {
  ignore_changes = [source_code_hash]  # ‚ùå BLOCKS code change detection
}
```

**Rules:**
1. Always include `source_code_hash = filebase64sha256(var.lambda_zip)`
2. Use `lifecycle { create_before_destroy = true }` for zero-downtime deployments
3. NEVER use `ignore_changes` on `source_code_hash` or `filename`
4. Lambda runtime MUST be `python3.11` (to match org-common layer)
5. All Lambdas MUST have `layers = [var.org_common_layer_arn]`

**See:** `docs/standards/standard_LAMBDA-DEPLOYMENT.md` for complete documentation.

**Impact if wrong:** Lambda code doesn't update when rebuilt, wasting 2-8 hours per module debugging stale code issues.

### When Updating Validation

1. Validation scripts integrate with `pm-app-stack/scripts/validation/`
2. Create wrapper orchestrator (`cora-validate.py`)
3. Support module-level and project-level validation

## CORA Projects Using This Toolkit

| Project           | Status        | Repos                      |
| ----------------- | ------------- | -------------------------- |
| pm-app            | In Production | pm-app-infra, pm-app-stack |
| (future projects) | Planned       | Created via toolkit        |

## Implementation Plan Tracking

The master plan is in `docs/CORA-DEVELOPMENT-TOOLKIT-PLAN.md`.

Phase progress:

- Phase 1: Documentation Foundation ‚úÖ COMPLETE
- Phase 2: Project Templates ‚úÖ COMPLETE
- Phase 3: Validation Framework (pending)
- Phase 4: Module Registry (pending)
- Phase 5: Core Module Templates (pending)
- Phase 6: Retrofit & Testing (pending)

Always update the plan's checklists when completing items.

## üö® CRITICAL: Template-First Workflow

**Test projects (like ai-sec, pm-app-test, etc.) are TEMPORARY and will be DELETED.**

**ALL changes must be made to TEMPLATES first, then copied to test projects.**

### The Correct Workflow:

1. **ALWAYS update the template FIRST**
   - `templates/_project-infra-template/` for infrastructure changes
   - `templates/_project-stack-template/` for application changes
   - `templates/_cora-core-modules/` for core module changes

2. **THEN copy changes to the test project**
   - Use the updated template as source
   - Test the change in the test project
   - Verify it works correctly

3. **NEVER make changes ONLY to test projects**
   - Test projects will be deleted on next practice run
   - Changes made only to test projects are LOST FOREVER
   - This wastes time and creates confusion

### Example: Fixing a Build Script

‚ùå **WRONG (What you were doing):**
```bash
# Update ai-sec build script directly
cd ~/code/sts/security/ai-sec-infra/lambdas/authorizer
# Make changes to build.sh
```

‚úÖ **CORRECT:**
```bash
# 1. Update template FIRST
cd cora-dev-toolkit/templates/_project-infra-template/lambdas/authorizer
# Make changes to build.sh

# 2. THEN copy to test project
cp build.sh ~/code/sts/security/ai-sec-infra/lambdas/authorizer/build.sh

# 3. Test in test project
cd ~/code/sts/security/ai-sec-infra/lambdas/authorizer
./build.sh
```

### Why This Matters:

- **Test projects are ephemeral** - They exist only for testing and will be deleted
- **Templates are permanent** - They create all future projects
- **Fixes must persist** - If you only fix the test project, the bug returns in the next project
- **No wasted work** - Updating templates ensures your work benefits all future projects

## AI Agent Instructions

When working on this toolkit:

1. **USE WORKFLOWS FIRST** - Check `.cline/workflows/` for established workflows before making up approaches
   - Available workflows: `test-module.md`, `validate.md`, `fix-cycle.md`, `fix-and-sync.md`, `fix-backend.md`, `fix-data.md`, `fix-frontend.md`, `fix-structure.md`
   - These workflows save time and tokens by following proven patterns
   - Run `/help-validation.md` to see all available workflows
2. **Read memory-bank first** - Understand current context
3. **Check the plan** - What phase are we in?
4. **FOLLOW TEMPLATE-FIRST WORKFLOW** - See critical rule above
4. **VERIFY FACTS BEFORE ASSUMING** - Check timestamps, file contents, and actual state before making statements. Never say "the user needs to recreate the project" without checking if they already did. Use tools to verify facts, not assumptions.
5. **EXPLAIN CHANGES FIRST** - Always provide an explanation of what you are doing and why before proposing a change that requires user approval (saving files).
6. **Make focused changes** - One deliverable at a time
7. **Update progress** - Mark items complete in plan
8. **Test changes** - Validate scripts work
9. **Document patterns** - Update docs with new patterns

## üöÄ Cline Workflows

**CRITICAL:** Before making up an approach, check if a workflow exists in `.cline/workflows/`.

### Available Workflows

| Workflow | When to Use | Command |
|----------|-------------|---------|
| **test-module.md** | Full testing pipeline for new modules | `/test-module.md <module-name> <ws-number>` |
| **validate.md** | Run full validation suite | `/validate.md` |
| **fix-cycle.md** | Iterative error fixing | `/fix-cycle.md` |
| **fix-and-sync.md** | Fix template and sync to test project | `/fix-and-sync.md <filename>` |
| **fix-backend.md** | Backend expertise (Lambda, API, Auth) | `/fix-backend.md` |
| **fix-data.md** | Database expertise (Schema, Naming, RLS) | `/fix-data.md` |
| **fix-frontend.md** | Frontend expertise (A11y, UI) | `/fix-frontend.md` |
| **fix-structure.md** | Structure expertise (Imports, Files) | `/fix-structure.md` |
| **validate-backend.md** | Backend validation only | `/validate-backend.md` |
| **validate-frontend.md** | Frontend validation only | `/validate-frontend.md` |
| **help-validation.md** | Show workflow help | `/help-validation.md` |

### Workflow Philosophy

These workflows:
- **Save time and tokens** by following proven patterns
- **Reduce errors** by using standardized approaches
- **Ensure consistency** across all operations
- **Enforce template-first** workflow automatically

### When to Use Workflows

**Instead of manually:**
- Creating test projects ‚Üí Use `/test-module.md`
- Fixing errors ‚Üí Use `/fix-cycle.md` or domain-specific `/fix-*.md`
- Validating code ‚Üí Use `/validate.md`
- Syncing fixes ‚Üí Use `/fix-and-sync.md`

**Always prefer workflows over ad-hoc manual approaches.**

## üìä Fast Iteration Testing Workflow (AI-Assisted)

**Prefer using `/fix-and-sync.md <filename>` workflow instead of manual steps.**

**When user reports a bug or test failure, follow this workflow to minimize their effort:**

### Step 1: Fix the Template
Make the fix in the template file (ALWAYS templates first, never test projects).

### Step 2: Sync Fix to Test Project
After fixing template, automatically sync to user's test project:

```bash
# Frontend fix
./scripts/sync-fix-to-project.sh ~/code/bodhix/testing/test-ws-23/ai-sec-stack <filename> --dry-run
# If dry-run looks good, run without --dry-run

# Backend Lambda fix  
./scripts/sync-fix-to-project.sh ~/code/bodhix/testing/test-ws-23/ai-sec-infra "<lambda>/lambda_function.py" --dry-run

# Infrastructure fix (Terraform .tf files)
./scripts/sync-infra-to-project.sh ~/code/bodhix/testing/test-ws-23/ai-sec-stack module-eval/infrastructure/main.tf --dry-run
# If dry-run looks good, run without --dry-run
```

### Step 3: Deploy if Backend Change
For Lambda changes, also deploy:
```bash
cd ~/code/bodhix/testing/test-ws-23/ai-sec-infra
./scripts/deploy-lambda.sh module-access/<lambda-name>
```

### Step 4: Notify User
Tell the user:
- "‚úÖ Fix applied to template and synced to test project"
- "Frontend: Restart dev server (`./scripts/start-dev.sh`) and retest"
- "Backend: Lambda deployed, retest the API"

### Script Reference

| Script | When to Use |
|--------|-------------|
| `./scripts/sync-fix-to-project.sh <stack-path> <file>` | Frontend/backend files (lambdas, components, hooks) |
| `./scripts/sync-infra-to-project.sh <stack-path> <file>` | **Infrastructure files (Terraform .tf files)** |
| `./scripts/deploy-lambda.sh <module>/<lambda>` | After backend Lambda fix |

### Path Patterns for sync-fix-to-project.sh

- **Filename only**: `InviteMemberDialog.tsx` (works if unique)
- **With parent dir**: `"orgs/lambda_function.py"` (for Lambdas)
- **Module path**: `"module-access/invites"` (narrows search)

### Path Patterns for sync-infra-to-project.sh

- **Module infrastructure**: `module-eval/infrastructure/main.tf`
- **Specific file**: `module-voice/infrastructure/outputs.tf`
- **By filename**: `module-kb/main.tf` (searches infrastructure directories)
- **Dry run first**: Add `--dry-run` to preview changes

### User's Test Project Paths

**IMPORTANT:** Test project paths are configured in `memory-bank/activeContext.md` under the "Current Test Environment" section. Check that file for the current paths before syncing.

**Goal:** User only needs to TEST. AI handles fix + sync + deploy.

## ÔøΩüö® CRITICAL: Use Standard Deployment Scripts

**ALL deployments MUST use the standard scripts in {project}-infra/scripts/**

**NEVER call terraform commands directly from envs/dev/ directory.**

### The Rule:

‚úÖ **Use Standard Scripts:**
```bash
# From project root (e.g., ai-sec-infra)
cd ~/code/sts/security/ai-sec-infra
./scripts/deploy-terraform.sh dev
```

‚ùå **DON'T call Terraform directly:**
```bash
# DON'T do this!
cd ~/code/sts/security/ai-sec-infra/envs/dev
terraform apply -var-file=local-secrets.tfvars
```

### Why Standard Scripts:

1. **Consistent Environment Setup:** Scripts set correct AWS_PROFILE and variables
2. **Validation:** Scripts check prerequisites before deployment
3. **Logging:** Scripts provide better output and error handling
4. **Safety:** Scripts have built-in guards and confirmations
5. **Maintainability:** Script changes benefit all deployments

### Available Standard Scripts:

- `scripts/deploy-terraform.sh [env]` - Deploy infrastructure
- `scripts/bootstrap/bootstrap_tf_state.sh` - Bootstrap Terraform state
- `scripts/build-and-deploy.sh` - Build and deploy in one command
- Other project-specific scripts in `scripts/` directory

## üö® CRITICAL: Terraform-Only Deployments

**ALL infrastructure changes MUST be deployed through the standard scripts (which use Terraform).**

**NEVER use AWS CLI to create, update, or delete infrastructure resources.**

### The Rule:

‚úÖ **Standard Scripts (which use Terraform) for ALL Infrastructure:**
- Create resources: `./scripts/deploy-terraform.sh dev`
- Update resources: `./scripts/deploy-terraform.sh dev`
- All changes tracked in Terraform state

‚ùå **AWS CLI for Verification ONLY:**
- View configurations: `aws lambda get-function-configuration`
- Check logs: `aws logs tail /aws/lambda/...`
- Verify deployment: `aws lambda list-functions`
- NO create/update/delete commands

### Why This Matters:

1. **Prevents Drift:** Manual changes via CLI create drift between Terraform and reality
2. **Audit Trail:** All changes tracked in Terraform state and version control
3. **Reproducibility:** Infrastructure is code, can be recreated exactly
4. **Safety:** Terraform plans show exactly what will change before applying
5. **Team Collaboration:** Everyone sees infrastructure changes in code reviews

### Examples:

‚ùå **WRONG:**
```bash
# Don't do this!
aws lambda update-function-configuration --function-name my-function --timeout 60
aws lambda update-function-code --function-name my-function --zip-file fileb://code.zip
```

‚úÖ **CORRECT:**
```bash
# Update Terraform config
# Edit main.tf to change timeout or code

# Deploy through Terraform
terraform plan -var-file=local-secrets.tfvars
terraform apply -var-file=local-secrets.tfvars
```

‚úÖ **CLI for Verification (OK):**
```bash
# These are fine - read-only operations
aws lambda get-function-configuration --function-name my-function
aws logs tail /aws/lambda/my-function
aws apigatewayv2 get-routes --api-id abc123
```

## Do NOT

- **Do NOT update test projects before templates** - See CRITICAL rule above
- **Do NOT make changes only to test projects** - Changes will be lost when project is deleted
- **Do NOT use AWS CLI for infrastructure changes** - Terraform only! (See rule above)
- **Do NOT deploy infrastructure manually** - All deployments through Terraform
- Do not hardcode project-specific values (pm-app, us-east-1, etc.)
- Do not create one-off solutions - everything should be reusable
- Do not skip documentation - all changes need docs
- Do not break existing functionality in pm-app projects
