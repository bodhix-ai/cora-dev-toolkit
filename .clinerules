# CORA Development Toolkit - Cline Rules

## Project Overview

This is the **CORA Development Toolkit** repository - the authoritative source for CORA (Composable Organizational Resource Architecture) standards, templates, and tooling. This toolkit is used to create and develop CORA-compliant applications.

## Purpose

This toolkit enables:

1. **New CORA Project Creation** - Scaffolding for {project}-infra and {project}-stack repos
2. **Module Development** - Templates and validation for CORA modules
3. **Compliance Validation** - Automated checking of CORA standards
4. **Documentation** - Comprehensive guides for developers and AI agents

## Repository Structure

```
cora-dev-toolkit/
‚îú‚îÄ‚îÄ .clinerules                 # This file - AI agent instructions
‚îú‚îÄ‚îÄ .gitignore                  # Git ignore patterns
‚îú‚îÄ‚îÄ README.md                   # Toolkit overview
‚îú‚îÄ‚îÄ INTEGRATION-GUIDE.md        # How to use the toolkit
‚îú‚îÄ‚îÄ config/                     # Linting and dependency configs
‚îú‚îÄ‚îÄ docs/                       # CORA standards documentation
‚îú‚îÄ‚îÄ scripts/                    # Automation scripts
‚îú‚îÄ‚îÄ templates/                  # Project and module templates
‚îî‚îÄ‚îÄ memory-bank/                # AI context for toolkit development
```

## Key Documents

Before making changes, review these in order:

1. `memory-bank/README.md` - Current toolkit context
2. `docs/CORA-DEVELOPMENT-TOOLKIT-PLAN.md` - Master implementation plan
3. `docs/CORA-PROJECT-BOILERPLATE.md` - Project creation standards (when created)
4. `docs/CORA-CORE-MODULES.md` - Core module specifications (when created)

## Module Naming Convention

CORA uses a strict naming convention for modules:

```
module-{purpose}
```

Where `{purpose}` is a **single word** describing the module's main responsibility.

### Core Modules (Required)

- `module-access` - Identity & access control (Tier 1)
- `module-ai` - AI provider management (Tier 2)
- `module-mgmt` - Platform management & monitoring (Tier 3)

### Functional Modules (Per-Feature)

- `module-kb` - Knowledge base
- `module-chat` - Chat & messaging
- `module-project` - Project management
- `module-dashboard` - Analytics dashboard
- etc.

## Two-Repo Pattern

Every CORA project uses two repositories:

- `{project}-infra` - Infrastructure as Code (Terraform, deploy scripts)
- `{project}-stack` - Application Code (Next.js app, CORA modules)

## Development Guidelines

### When Creating Templates

1. Use `{project}` placeholder for project-specific names
2. Use `{module}` placeholder for module-specific names
3. Never hardcode project prefixes like `pm-app-`
4. All infrastructure must be configurable via variables

### When Creating Documentation

1. Documentation lives in `docs/`
2. Use clear, actionable language
3. Include examples and anti-patterns
4. Reference the implementation plan phases

### When Creating Scripts

1. Scripts live in `scripts/`
2. Make scripts executable (`chmod +x`)
3. Include `--help` option
4. Support `--dry-run` for destructive operations

### When Updating Validation

1. Validation scripts integrate with `pm-app-stack/scripts/validation/`
2. Create wrapper orchestrator (`cora-validate.py`)
3. Support module-level and project-level validation

## CORA Projects Using This Toolkit

| Project           | Status        | Repos                      |
| ----------------- | ------------- | -------------------------- |
| pm-app            | In Production | pm-app-infra, pm-app-stack |
| (future projects) | Planned       | Created via toolkit        |

## Implementation Plan Tracking

The master plan is in `docs/CORA-DEVELOPMENT-TOOLKIT-PLAN.md`.

Phase progress:

- Phase 1: Documentation Foundation ‚úÖ COMPLETE
- Phase 2: Project Templates ‚úÖ COMPLETE
- Phase 3: Validation Framework (pending)
- Phase 4: Module Registry (pending)
- Phase 5: Core Module Templates (pending)
- Phase 6: Retrofit & Testing (pending)

Always update the plan's checklists when completing items.

## üö® CRITICAL: Template-First Workflow

**Test projects (like ai-sec, pm-app-test, etc.) are TEMPORARY and will be DELETED.**

**ALL changes must be made to TEMPLATES first, then copied to test projects.**

### The Correct Workflow:

1. **ALWAYS update the template FIRST**
   - `templates/_project-infra-template/` for infrastructure changes
   - `templates/_project-stack-template/` for application changes
   - `templates/_cora-core-modules/` for core module changes

2. **THEN copy changes to the test project**
   - Use the updated template as source
   - Test the change in the test project
   - Verify it works correctly

3. **NEVER make changes ONLY to test projects**
   - Test projects will be deleted on next practice run
   - Changes made only to test projects are LOST FOREVER
   - This wastes time and creates confusion

### Example: Fixing a Build Script

‚ùå **WRONG (What you were doing):**
```bash
# Update ai-sec build script directly
cd ~/code/sts/security/ai-sec-infra/lambdas/authorizer
# Make changes to build.sh
```

‚úÖ **CORRECT:**
```bash
# 1. Update template FIRST
cd cora-dev-toolkit/templates/_project-infra-template/lambdas/authorizer
# Make changes to build.sh

# 2. THEN copy to test project
cp build.sh ~/code/sts/security/ai-sec-infra/lambdas/authorizer/build.sh

# 3. Test in test project
cd ~/code/sts/security/ai-sec-infra/lambdas/authorizer
./build.sh
```

### Why This Matters:

- **Test projects are ephemeral** - They exist only for testing and will be deleted
- **Templates are permanent** - They create all future projects
- **Fixes must persist** - If you only fix the test project, the bug returns in the next project
- **No wasted work** - Updating templates ensures your work benefits all future projects

## AI Agent Instructions

When working on this toolkit:

1. **Read memory-bank first** - Understand current context
2. **Check the plan** - What phase are we in?
3. **FOLLOW TEMPLATE-FIRST WORKFLOW** - See critical rule above
4. **EXPLAIN CHANGES FIRST** - Always provide an explanation of what you are doing and why before proposing a change that requires user approval (saving files).
5. **Make focused changes** - One deliverable at a time
6. **Update progress** - Mark items complete in plan
7. **Test changes** - Validate scripts work
8. **Document patterns** - Update docs with new patterns

## üö® CRITICAL: Use Standard Deployment Scripts

**ALL deployments MUST use the standard scripts in {project}-infra/scripts/**

**NEVER call terraform commands directly from envs/dev/ directory.**

### The Rule:

‚úÖ **Use Standard Scripts:**
```bash
# From project root (e.g., ai-sec-infra)
cd ~/code/sts/security/ai-sec-infra
./scripts/deploy-terraform.sh dev
```

‚ùå **DON'T call Terraform directly:**
```bash
# DON'T do this!
cd ~/code/sts/security/ai-sec-infra/envs/dev
terraform apply -var-file=local-secrets.tfvars
```

### Why Standard Scripts:

1. **Consistent Environment Setup:** Scripts set correct AWS_PROFILE and variables
2. **Validation:** Scripts check prerequisites before deployment
3. **Logging:** Scripts provide better output and error handling
4. **Safety:** Scripts have built-in guards and confirmations
5. **Maintainability:** Script changes benefit all deployments

### Available Standard Scripts:

- `scripts/deploy-terraform.sh [env]` - Deploy infrastructure
- `scripts/bootstrap/bootstrap_tf_state.sh` - Bootstrap Terraform state
- `scripts/build-and-deploy.sh` - Build and deploy in one command
- Other project-specific scripts in `scripts/` directory

## üö® CRITICAL: Terraform-Only Deployments

**ALL infrastructure changes MUST be deployed through the standard scripts (which use Terraform).**

**NEVER use AWS CLI to create, update, or delete infrastructure resources.**

### The Rule:

‚úÖ **Standard Scripts (which use Terraform) for ALL Infrastructure:**
- Create resources: `./scripts/deploy-terraform.sh dev`
- Update resources: `./scripts/deploy-terraform.sh dev`
- All changes tracked in Terraform state

‚ùå **AWS CLI for Verification ONLY:**
- View configurations: `aws lambda get-function-configuration`
- Check logs: `aws logs tail /aws/lambda/...`
- Verify deployment: `aws lambda list-functions`
- NO create/update/delete commands

### Why This Matters:

1. **Prevents Drift:** Manual changes via CLI create drift between Terraform and reality
2. **Audit Trail:** All changes tracked in Terraform state and version control
3. **Reproducibility:** Infrastructure is code, can be recreated exactly
4. **Safety:** Terraform plans show exactly what will change before applying
5. **Team Collaboration:** Everyone sees infrastructure changes in code reviews

### Examples:

‚ùå **WRONG:**
```bash
# Don't do this!
aws lambda update-function-configuration --function-name my-function --timeout 60
aws lambda update-function-code --function-name my-function --zip-file fileb://code.zip
```

‚úÖ **CORRECT:**
```bash
# Update Terraform config
# Edit main.tf to change timeout or code

# Deploy through Terraform
terraform plan -var-file=local-secrets.tfvars
terraform apply -var-file=local-secrets.tfvars
```

‚úÖ **CLI for Verification (OK):**
```bash
# These are fine - read-only operations
aws lambda get-function-configuration --function-name my-function
aws logs tail /aws/lambda/my-function
aws apigatewayv2 get-routes --api-id abc123
```

## Do NOT

- **Do NOT update test projects before templates** - See CRITICAL rule above
- **Do NOT make changes only to test projects** - Changes will be lost when project is deleted
- **Do NOT use AWS CLI for infrastructure changes** - Terraform only! (See rule above)
- **Do NOT deploy infrastructure manually** - All deployments through Terraform
- Do not hardcode project-specific values (pm-app, us-east-1, etc.)
- Do not create one-off solutions - everything should be reusable
- Do not skip documentation - all changes need docs
- Do not break existing functionality in pm-app projects
